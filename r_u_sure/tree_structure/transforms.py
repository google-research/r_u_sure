# coding=utf-8
# Copyright 2023 The R-U-SURE Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Functions for transforming node sequences.

Transformations allow conversion from raw, tree-like inputs (such as those
generated by a parser) into sequences with extra metadata (such as region
starting and ending points and early-exit points), which can then be passed
to utility functions.
"""
import dataclasses
from typing import List, Iterable, Callable

from r_u_sure.tree_structure import sequence_nodes


def flatten_groups(
    sequence: List[sequence_nodes.SequenceNode],
) -> List[sequence_nodes.SequenceNode]:
  """Inlines all children of group nodes.

  Args:
    sequence: The sequence to process.

  Returns:
    Version of this sequence where all group nodes have been replaced by their
    inlined children (recursively).
  """
  result = []
  for node in sequence:
    if isinstance(node, sequence_nodes.GroupNode):
      result.extend(flatten_groups(node.children))
    else:
      result.append(node)
  return result


def flatten_singleton_groups(
    sequence: List[sequence_nodes.SequenceNode],
) -> List[sequence_nodes.SequenceNode]:
  """Inlines groups with a single (group or token) child.

  All node types will be replaced by tuples containing collapsed node types,
  so that information about node types is retained (allowing reconstruction of
  the original tree structure, and comparison of whether all collapsed group
  nodes were compatible between two trees).

  Args:
    sequence: The sequence to process.

  Returns:
    Version of this sequence where all group nodes with exactly one child have
    been replaced by their inlined children (recursively).
  """
  return [flatten_singleton_groups_for_node(node) for node in sequence]


def flatten_singleton_groups_for_node(
    node: sequence_nodes.SequenceNode,
) -> sequence_nodes.SequenceNode:
  """Inlines groups with a single (group or token) child, starting at a node.

  All node types will be replaced by tuples containing collapsed node types.

  Args:
    node: The node to process.

  Returns:
    Version of this node where all group nodes with exactly one child have
    been replaced by their inlined children (recursively).
  """
  if isinstance(node, sequence_nodes.GroupNode):
    if len(node.children) == 1 and isinstance(
        node.children[0],
        (sequence_nodes.GroupNode, sequence_nodes.TextTokenNode),
    ):
      processed = flatten_singleton_groups_for_node(node.children[0])
      assert isinstance(
          processed, (sequence_nodes.GroupNode, sequence_nodes.TextTokenNode)
      )
      # Splice in this node's match type.
      return dataclasses.replace(
          processed, match_type=(node.match_type,) + processed.match_type
      )

    else:
      # Process children, and wrap node type in a tuple.
      return sequence_nodes.GroupNode(
          children=flatten_singleton_groups(node.children),
          match_type=(node.match_type,),
      )
  elif isinstance(node, sequence_nodes.TextTokenNode):
    # Wrap node type in a tuple.
    return sequence_nodes.TextTokenNode(
        text_contents=node.text_contents, match_type=(node.match_type,)
    )
  else:
    return node


def insert_early_exit(
    sequence: List[sequence_nodes.SequenceNode],
    allowed_within_group: bool = True,
    allowed_at_start: bool = True,
) -> List[sequence_nodes.SequenceNode]:
  """Inserts early exit nodes into a sequence.

  Early exit nodes determine where we are allowed to end a template. This
  function inserts early exit nodes after each token or group in the sequence.

  Note: This function should be called BEFORE inserting region start/end
  nodes, because then the early exit nodes will remain outside the regions.

  Args:
    sequence: The sequence to insert nodes into.
    allowed_within_group: Whether we can early exit while inside group nodes.
    allowed_at_start: Whether we can early exit at the start of the sequence.

  Returns:
    Extended sequence with early exit nodes.
  """
  result = []
  if allowed_at_start:
    result.append(sequence_nodes.EarlyExitNode())
  for node in sequence:
    if isinstance(node, sequence_nodes.GroupNode) and allowed_within_group:
      # Don't allow early exit at start of a group's children, since we
      # already handle early exit before the group node itself.
      processed_group_node = dataclasses.replace(
          node,
          children=insert_early_exit(
              node.children, allowed_within_group=True, allowed_at_start=False
          ),
      )
      result.append(processed_group_node)
      result.append(sequence_nodes.EarlyExitNode())
    elif isinstance(
        node, (sequence_nodes.TextTokenNode, sequence_nodes.GroupNode)
    ):
      result.append(node)
      result.append(sequence_nodes.EarlyExitNode())
    else:
      result.append(node)

  return result


def insert_region_options_around_subsequences(
    sequence: List[sequence_nodes.SequenceNode],
    allow_empty_regions: bool = True,
    node_filter: Callable[[sequence_nodes.SequenceNode], bool] = lambda _: True,
) -> List[sequence_nodes.SequenceNode]:
  """Inserts region options, around subsequences of each sequence.

  Region options are insrted so that regions can freely surround
  arbitrary groups of consecutive children at each level.

  Decoration nodes are kept outside of regions where possible.

  Args:
    sequence: The sequence to insert nodes into.
    allow_empty_regions: Whether to allow empty regions by having
      region start and end nodes adjacent to each other.
    node_filter: Function which is called to determine if we should insert
      region start and end nodes around each token or group node. If it
      returns False, no start node is added before this node, and no end node is
      added afterward. (Children are still processed recursively.)

  Returns:
    Extended sequence with region start/end nodes.
  """
  result = []
  for node in sequence:
    if isinstance(
        node, (sequence_nodes.TextTokenNode, sequence_nodes.GroupNode)
    ):
      if isinstance(node, sequence_nodes.GroupNode):
        processed_node = dataclasses.replace(
            node,
            children=insert_region_options_around_subsequences(
                node.children,
                allow_empty_regions=allow_empty_regions,
                node_filter=node_filter,
            ),
        )
      else:
        processed_node = node

      if node_filter(node):
        result.append(sequence_nodes.RegionStartNode())
        if allow_empty_regions:
          result.append(sequence_nodes.RegionEndNode())
        result.append(processed_node)
        result.append(sequence_nodes.RegionEndNode())
      else:
        result.append(processed_node)

    else:
      # Decoration or other node
      result.append(node)

  if allow_empty_regions:
    result.append(sequence_nodes.RegionStartNode())
    result.append(sequence_nodes.RegionEndNode())

  return result


def insert_region_options_around_single_nodes(
    sequence: List[sequence_nodes.SequenceNode],
) -> List[sequence_nodes.SequenceNode]:
  """Inserts region options, around individual nodes.

  Regions respect strict tree structure, in the sense that group nodes
  will only ever match with other group nodes with exactly the same number of
  children, and a region always replaces a single node.

  We accomplish this by inserting new group nodes around anything that could
  be put in a region, and surrounding the child node with region
  options. This "region_scope" group prevents regions from extending
  beyond the individual element.

  Args:
    sequence: The sequence to insert nodes into.

  Returns:
    Extended sequence with region start/end nodes.
  """
  result = []
  for node in sequence:
    if isinstance(
        node, (sequence_nodes.TextTokenNode, sequence_nodes.GroupNode)
    ):
      if isinstance(node, sequence_nodes.GroupNode):
        processed_node = dataclasses.replace(
            node,
            children=insert_region_options_around_single_nodes(
                node.children
            ),
        )
      else:
        processed_node = node

      result.append(
          sequence_nodes.GroupNode(
              children=[
                  sequence_nodes.RegionStartNode(),
                  processed_node,
                  sequence_nodes.RegionEndNode(),
              ],
              match_type="region_scope",
          )
      )

    else:
      # Decoration or other node
      result.append(node)

  return result


def truncate_prefix_at_offset(
    sequence: List[sequence_nodes.SequenceNode],
    start_offset: int,
) -> List[sequence_nodes.SequenceNode]:
  """Removes the prefix of a sequence at a character offset.

  This can be used to remove the context from a model suggestion after parsing.
  This method should be called AFTER inserting region start/end nodes,
  which ensures that nodes that have already started before the cursor can't
  be put in regions.

  Args:
    sequence: The sequence to truncate.
    start_offset: The number of characters to truncate at.

  Returns:
    Extended sequence with region start/end nodes.
  """
  # Tracks whether we have seen the start point yet.
  past_start_point = False
  # If past_start_point is False, tracks the characters we have seen so far.
  prefix_chars_seen_so_far = 0

  def process_subsequence(
      nodes: Iterable[sequence_nodes.SequenceNode],
  ) -> Iterable[sequence_nodes.SequenceNode]:
    """Processes a sequence of nodes."""
    nonlocal prefix_chars_seen_so_far, past_start_point
    for node in nodes:
      if isinstance(node, sequence_nodes.GroupNode):
        processed_subsequence = list(process_subsequence(node.children))
        if past_start_point:
          # Part of this node is within the prefix.
          yield dataclasses.replace(
              node,
              children=processed_subsequence,
          )
        else:
          # This node is entirely within the prefix. Drop it.
          assert not processed_subsequence

      elif isinstance(
          node,
          (sequence_nodes.TextTokenNode, sequence_nodes.TextDecorationNode),
      ):
        if past_start_point:
          yield node
        else:
          offset_into_node = start_offset - prefix_chars_seen_so_far
          if offset_into_node < len(node.text_contents):
            # The start offset happens in this node!
            yield dataclasses.replace(
                node, text_contents=node.text_contents[offset_into_node:]
            )
            past_start_point = True
            prefix_chars_seen_so_far = None
          elif offset_into_node == len(node.text_contents):
            # The start offset happens immediately after this node.
            past_start_point = True
            prefix_chars_seen_so_far = None
          else:
            prefix_chars_seen_so_far += len(node.text_contents)

      elif isinstance(
          node,
          (
              sequence_nodes.RegionStartNode,
              sequence_nodes.RegionEndNode,
              sequence_nodes.EarlyExitNode,
          ),
      ):
        if past_start_point:
          yield node
      else:
        raise ValueError(node)

  return list(process_subsequence(sequence))


def strip_decision_nodes(
    sequence: List[sequence_nodes.SequenceNode],
) -> List[sequence_nodes.SequenceNode]:
  """Strips out decision nodes."""
  result = []
  for node in sequence:
    if isinstance(node, sequence_nodes.GroupNode):
      # Don't allow early exit at start of a group's children, since we
      # already handle early exit before the group node itself.
      processed_group_node = dataclasses.replace(
          node,
          children=strip_decision_nodes(node.children),
      )
      result.append(processed_group_node)
    elif isinstance(
        node, (sequence_nodes.TextTokenNode, sequence_nodes.TextDecorationNode)
    ):
      result.append(node)
    elif isinstance(
        node,
        (
            sequence_nodes.RegionStartNode,
            sequence_nodes.RegionEndNode,
            sequence_nodes.EarlyExitNode,
        ),
    ):
      pass
    else:
      raise ValueError

  return result
