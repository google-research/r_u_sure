# coding=utf-8
# Copyright 2023 The R-U-SURE Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Interface for interactive use of the R-U-SURE system."""

import dataclasses
import html
import itertools

from typing import Any, Optional, Sequence, Union

from IPython import display

from matplotlib import pyplot as plt
import numpy as np

from r_u_sure.decision_diagrams import consistent_path_dual_solver
from r_u_sure.tree_structure import token_prob_align
from r_u_sure.tree_structure import transforms
from r_u_sure.wrappers import parser_tools
from r_u_sure.wrappers import wrapper_base


@dataclasses.dataclass
class CombineResult:
  """A collection of results from combining a context with samples."""

  context_info: Any
  packed_prototype: wrapper_base.PackedSequenceNodeStorage
  packed_targets: list[wrapper_base.PackedSequenceNodeStorage]
  sample_system: wrapper_base.DualDecompositionDiagramSystem
  opt_results: consistent_path_dual_solver.MinMarginalSweepSolverResults
  utility_dual_bound: float
  solution_utility: float
  assignment_vector: Optional[np.ndarray]
  assignment_map: Optional[dict[Any, Any]]
  solution_info: Optional[dict[Any, Any]]


@dataclasses.dataclass
class BaselineResult:
  """A collection of results for a baseline."""

  context_info: Any
  packed_prototype: wrapper_base.PackedSequenceNodeStorage
  packed_prototype_as_target: wrapper_base.PackedSequenceNodeStorage
  assignment_map: Optional[dict[Any, Any]]
  solution_info: Optional[dict[Any, Any]]


EMPTY_RESULT_MESSAGE = (
    "Solver returned an empty result. This usually means the input was"
    " empty, so we could not build a suggestion. If using the call"
    " sequence wrapper, this may mean we did not identify any candidate"
    " function calls in the suggestion prototype."
)


class DemoRunner:
  """Runner object that simplifies running R-U-SURE on input strings."""

  def __init__(
      self,
      wrapper: wrapper_base.HighLevelUtilityWrapper,
      language: str = "python",
  ):
    """Constructs a demo runner.

    Args:
      wrapper: Task utility-function wrapper to use.
      language: Assumed language for the inputs.
    """
    self.wrapper = wrapper
    self.parser_helper = parser_tools.ParserHelper(language=language)

  def combine(
      self,
      context: str,
      samples: Sequence[str],
      prototype_index: int = 0,
  ) -> CombineResult:
    """Combines a set of samples.

    Args:
      context: The context for the samples. Should be the contents of a code
        file up until a particular cursor position.
      samples: A set of possible completions of `context` generated by a
        generative model.
      prototype_index: The index of the sample that should be designated as the
        suggestion prototype. The returned suggestion will always be produced by
        adding annotations to or truncating this sample.

    Returns:
      A collection of results that can be passed to other methods of the
      DemoRunner.
    """
    # Concatenate context and samples.
    cursor_position = len(context)
    combined_model_outputs = [context + sample for sample in samples]
    # Process prototype, possibly inserting annotation options.
    prototype_string = combined_model_outputs[prototype_index]
    prototype_as_nodes = self.parser_helper.parse_to_nodes(prototype_string)
    packed_prototype, context_info = self.wrapper.process_prototype_and_context(
        context_and_prototype=prototype_as_nodes,
        prediction_location=cursor_position,
    )
    # Process samples as "targets", i.e. as hypothetical user goal states.
    packed_targets = []
    for combined_sample in combined_model_outputs:
      sample_as_nodes = self.parser_helper.parse_to_nodes(combined_sample)
      packed_targets.append(
          self.wrapper.process_target(
              context_and_target=sample_as_nodes,
              prediction_location=cursor_position,
          )
      )
    # Build the dual decomposition system.
    sample_system = self.wrapper.build_system(
        prototype=packed_prototype,
        context_info=context_info,
        targets=packed_targets,
    )
    # Solve the system.
    opt_results = consistent_path_dual_solver.solve_system_with_sweeps(
        system_data=sample_system.data, soft_timeout=10.0
    )
    if not opt_results.objective_at_step.shape[0]:
      # Empty system.
      utility_dual_bound = np.nan
      solution_utility = np.nan
      assignment_vector = None
      assignment_map = None
      solution_info = None

    else:
      cost_dual_bound = opt_results.objective_at_step[-1]
      utility_dual_bound = -cost_dual_bound

      assignment_vector, cost_of_decoded_solution = (
          consistent_path_dual_solver.greedy_extract(
              sample_system.data,
              direction=consistent_path_dual_solver.SweepDirection.FORWARD,
          )
      )
      solution_utility = -cost_of_decoded_solution
      assignment_map = (
          consistent_path_dual_solver.assignments_from_assignment_vector(
              sample_system, assignment_vector
          )
      )
      solution_info = self.wrapper.solution_info(
          prototype=packed_prototype,
          evaluation_target=None,
          context_info=context_info,
          system=None,
          sample_system=sample_system,
          assignments=assignment_map,
      )

    return CombineResult(
        context_info=context_info,
        packed_prototype=packed_prototype,
        packed_targets=packed_targets,
        sample_system=sample_system,
        opt_results=opt_results,
        utility_dual_bound=utility_dual_bound,
        solution_utility=solution_utility,
        assignment_vector=assignment_vector,
        assignment_map=assignment_map,
        solution_info=solution_info,
    )

  def build_baselines(
      self,
      context: str,
      prototype_parts_with_log_probs: list[tuple[str, float]],
  ) -> dict[str, BaselineResult]:
    """Builds baselines.

    Args:
      context: The context for the samples. Should be the contents of a code
        file up until a particular cursor position.
      prototype_parts_with_log_probs: Pairs of (substring, log_prob) for model
        tokens for the suggestion prototype.

    Returns:
      A set of results for each baseline.
    """
    # Assemble the prototype from parts.
    prototype_parts_combined = "".join(
        part for part, _ in prototype_parts_with_log_probs
    )
    cursor_position = len(context)
    prototype_string = context + prototype_parts_combined
    # Process prototype.
    prototype_as_nodes = self.parser_helper.parse_to_nodes(prototype_string)
    packed_as_prototype, context_info = (
        self.wrapper.process_prototype_and_context(
            context_and_prototype=prototype_as_nodes,
            prediction_location=cursor_position,
        )
    )
    # Process prototype again as a target, without annotations. Some baselines
    # need this to construct a valid assignment.
    packed_as_target = self.wrapper.process_target(
        context_and_target=prototype_as_nodes,
        prediction_location=cursor_position,
    )
    # Build all baseline assignments.
    baseline_assignments = self.wrapper.build_baseline_assignments(
        prototype=packed_as_prototype,
        prototype_suggestion_as_target=packed_as_target,
        context_info=context_info,
        model_tokens_and_log_probs=prototype_parts_with_log_probs,
    )
    result = {}
    for name, assignment_map in baseline_assignments.items():
      solution_info = self.wrapper.solution_info(
          prototype=packed_as_prototype,
          evaluation_target=None,
          context_info=context_info,
          system=None,
          sample_system=None,
          assignments=assignment_map,
      )
      result[name] = BaselineResult(
          context_info=context_info,
          packed_prototype=packed_as_prototype,
          packed_prototype_as_target=packed_as_target,
          assignment_map=assignment_map,
          solution_info=solution_info,
      )
    return result

  def show_suggestion(self, result: Union[CombineResult, BaselineResult]):
    """Visualizes a suggestion."""
    if result.assignment_map is None:
      print(EMPTY_RESULT_MESSAGE)
    else:
      html_src = self.wrapper.render_solution_html(
          prototype=result.packed_prototype,
          context_info=result.context_info,
          assignments=result.assignment_map,
      )
      display.display(display.HTML(html_src))

  def get_extracted_parts(self, result: Union[CombineResult, BaselineResult]):
    """Shows extracted parts for a suggestion."""
    if (
        result.solution_info is None
        or "extracted_parts" not in result.solution_info
    ):
      return None

    parts_grouped_by_confidence = []
    for in_region, parts in itertools.groupby(
        result.solution_info["extracted_parts"], lambda v: v[1]
    ):
      combined_parts = "".join(part for (part, _) in parts)
      parts_grouped_by_confidence.append((combined_parts, in_region))
    return parts_grouped_by_confidence

  def show_edits(self, combine_result: CombineResult):
    """Shows extracted parts for a suggestion."""
    if combine_result.assignment_map is None:
      print(EMPTY_RESULT_MESSAGE)
    else:
      html_src = self.wrapper.render_pairwise_matching_html(
          prototype=combine_result.packed_prototype,
          context_info=combine_result.context_info,
          targets=combine_result.packed_targets,
          system=combine_result.sample_system,
          assignments=combine_result.assignment_map,
      )
      display.display(display.HTML(html_src))

  def show_utilities(self, combine_result: CombineResult):
    """Shows estimated utilities for each hypothetial intent."""
    if combine_result.assignment_map is None:
      print(EMPTY_RESULT_MESSAGE)
    else:
      for i, cost in enumerate(
          combine_result.solution_info["sample_system_costs_unsorted"]
      ):
        utility = -cost
        print(f"Target {i}: {np.round(utility, decimals=6)}")

  def show_optimization_details(self, combine_result: CombineResult):
    """Visualizes results from the optimization process."""
    if combine_result.assignment_map is None:
      print(EMPTY_RESULT_MESSAGE)
      return

    _, axs = plt.subplots(1, 3, figsize=(15, 5))
    opt_results = combine_result.opt_results

    # Invert costs to show utilities.
    axs[0].plot(
        np.arange(opt_results.objective_at_step.shape[0]),
        -opt_results.objective_at_step,
    )
    axs[0].set_xlabel("Solver iteration")
    axs[0].set_ylabel("Dual bound")

    axs[1].plot(opt_results.variable_at_step, -opt_results.objective_at_step)
    axs[1].set_xlabel("Index of updated variable")
    axs[1].set_ylabel("Dual bound")

    axs[2].plot(opt_results.time_at_sweep, -opt_results.objective_at_sweep)
    axs[2].set_xlabel("Wall clock time (seconds)")
    axs[2].set_ylabel("Dual bound")

    axs[0].axhline(
        y=combine_result.solution_utility, color="gray", dashes=[1, 1]
    )
    axs[1].axhline(
        y=combine_result.solution_utility, color="gray", dashes=[1, 1]
    )
    axs[2].axhline(
        y=combine_result.solution_utility, color="gray", dashes=[1, 1]
    )

  def show_token_probs(
      self,
      context: str,
      prototype_parts_with_log_probs: list[tuple[str, float]],
      parse_and_realign: bool,
  ):
    """Shows a suggestion annotated with probabilities.

    Args:
      context: The context for the samples. Should be the contents of a code
        file up until a particular cursor position.
      prototype_parts_with_log_probs: Pairs of (substring, log_prob) for model
        tokens for the suggestion prototype.
      parse_and_realign: Whether to realign the probabilities with parsed
        tokens.
    """
    if parse_and_realign:
      prototype_parts_combined = "".join(
          part for part, _ in prototype_parts_with_log_probs
      )
      prototype_string = context + prototype_parts_combined
      prototype_as_nodes = self.parser_helper.parse_to_nodes(prototype_string)
      truncated_prototype = transforms.truncate_prefix_at_offset(
          prototype_as_nodes, len(context)
      )
      packed_prototype = parser_tools.pack_sequence_from_pseudoparser(
          truncated_prototype, False
      )
      prototype_parts_with_log_probs = (
          token_prob_align.flatten_token_log_probs_from_parsed(
              packed_prototype,
              token_prob_align.align_token_log_probs(
                  prototype_parts_with_log_probs,
                  packed_prototype,
              ),
          )
      )

    html_src = (
        '<span style="white-space: pre; font-family: monospace;">'
        + html.escape(context)
        + "</span>"
        + token_prob_align.render_tokens_and_log_probs_to_html(
            prototype_parts_with_log_probs
        )
    )
    display.display(display.HTML(html_src))
